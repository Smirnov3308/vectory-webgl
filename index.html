<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vectory 3D - Particle System</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --background: 0 0% 3.9%;
      --foreground: 0 0% 98%;
      --card: 0 0% 3.9%;
      --card-foreground: 0 0% 98%;
      --popover: 0 0% 3.9%;
      --popover-foreground: 0 0% 98%;
      --primary: 0 0% 98%;
      --primary-foreground: 0 0% 9%;
      --secondary: 0 0% 14.9%;
      --secondary-foreground: 0 0% 98%;
      --muted: 0 0% 14.9%;
      --muted-foreground: 0 0% 63.9%;
      --accent: 0 0% 14.9%;
      --accent-foreground: 0 0% 98%;
      --destructive: 0 62.8% 30.6%;
      --destructive-foreground: 0 0% 98%;
      --border: 0 0% 14.9%;
      --input: 0 0% 14.9%;
      --ring: 0 0% 83.1%;
      --radius: 0.5rem;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: hsl(var(--background));
      color: hsl(var(--foreground));
      min-height: 100vh;
      display: flex;
      overflow: hidden;
      font-feature-settings: "cv02", "cv03", "cv04", "cv11";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { 
      background: hsl(var(--border)); 
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover { 
      background: hsl(var(--muted-foreground) / 0.5); 
    }
    
    /* Sidebar */
    #controls {
      width: 320px;
      min-width: 320px;
      background: hsl(var(--background));
      border-right: 1px solid hsl(var(--border));
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    .sidebar-header {
      padding: 16px 16px 12px;
      border-bottom: 1px solid hsl(var(--border));
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .logo-icon {
      width: 32px;
      height: 32px;
      background: hsl(var(--foreground));
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    
    .logo h1 {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }
    
    .logo-subtitle {
      font-size: 12px;
      color: hsl(var(--muted-foreground));
      margin-top: 4px;
    }
    
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    
    /* Sections */
    .section {
      margin-bottom: 6px;
    }
    
    .section-trigger {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 8px 10px;
      background: transparent;
      border: none;
      border-radius: calc(var(--radius) - 2px);
      color: hsl(var(--foreground));
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s;
      text-align: left;
    }
    
    .section-trigger:hover {
      background: hsl(var(--accent));
    }
    
    .section-trigger svg {
      width: 14px;
      height: 14px;
      color: hsl(var(--muted-foreground));
      transition: transform 0.2s;
    }
    
    .section.collapsed .section-trigger svg {
      transform: rotate(-90deg);
    }
    
    .section.collapsed .section-content {
      display: none;
    }
    
    .section-content {
      padding: 8px 10px 12px;
    }
    
    /* Control Groups */
    .control-group {
      margin-bottom: 12px;
    }
    
    .control-group:last-child {
      margin-bottom: 0;
    }
    
    label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: hsl(var(--muted-foreground));
      margin-bottom: 6px;
    }
    
    label .value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: hsl(var(--foreground));
      background: hsl(var(--muted));
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    /* Inputs */
    input[type="range"] {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      background: hsl(var(--secondary));
      border-radius: 4px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: hsl(var(--foreground));
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
      box-shadow: 0 0 0 0 hsl(var(--ring) / 0);
    }
    
    input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 0 2px hsl(var(--background)), 0 0 0 4px hsl(var(--ring));
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: hsl(var(--foreground));
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    
    select {
      width: 100%;
      height: 36px;
      padding: 0 32px 0 12px;
      background: hsl(var(--background));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      color: hsl(var(--foreground));
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23a1a1aa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }
    
    select:hover {
      border-color: hsl(var(--ring) / 0.5);
    }
    
    select:focus {
      border-color: hsl(var(--ring));
      box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
    }
    
    input[type="file"] {
      width: 100%;
      height: 36px;
      padding: 6px 12px;
      background: hsl(var(--background));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      color: hsl(var(--foreground));
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      outline: none;
      transition: border-color 0.15s;
    }
    
    input[type="file"]:hover {
      border-color: hsl(var(--ring) / 0.5);
    }
    
    input[type="file"]::file-selector-button {
      display: none;
    }
    
    input[type="color"] {
      width: 100%;
      height: 36px;
      padding: 4px;
      background: hsl(var(--background));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      cursor: pointer;
      outline: none;
      transition: border-color 0.15s;
    }
    
    input[type="color"]:hover {
      border-color: hsl(var(--ring) / 0.5);
    }
    
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 2px;
    }
    
    input[type="color"]::-webkit-color-swatch {
      border-radius: calc(var(--radius) - 4px);
      border: none;
    }
    
    /* Checkbox */
    .checkbox-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .checkbox-wrapper input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: hsl(var(--foreground));
      cursor: pointer;
      border-radius: 4px;
    }
    
    .checkbox-wrapper label {
      margin: 0;
      font-size: 13px;
      color: hsl(var(--foreground));
      cursor: pointer;
    }
    
    /* Buttons */
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      height: 36px;
      padding: 0 16px;
      background: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
      border: none;
      border-radius: var(--radius);
      font-size: 13px;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      outline: none;
      transition: opacity 0.15s, transform 0.1s;
      white-space: nowrap;
    }
    
    button:hover {
      opacity: 0.9;
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    button:focus-visible {
      box-shadow: 0 0 0 2px hsl(var(--background)), 0 0 0 4px hsl(var(--ring));
    }
    
    button.secondary {
      background: hsl(var(--secondary));
      color: hsl(var(--secondary-foreground));
    }
    
    button.outline {
      background: transparent;
      border: 1px solid hsl(var(--border));
      color: hsl(var(--foreground));
    }
    
    button.outline:hover {
      background: hsl(var(--accent));
      opacity: 1;
    }
    
    button.ghost {
      background: transparent;
      color: hsl(var(--foreground));
    }
    
    button.ghost:hover {
      background: hsl(var(--accent));
      opacity: 1;
    }
    
    button.destructive {
      background: hsl(0 62.8% 30.6%);
      color: hsl(var(--foreground));
    }
    
    /* Preset Grid */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }
    
    .preset-grid button {
      height: 32px;
      font-size: 12px;
      padding: 0 10px;
    }
    
    /* Camera Button */
    .camera-btn {
      width: 100%;
      margin-bottom: 8px;
      background: linear-gradient(135deg, hsl(280 70% 50%) 0%, hsl(320 70% 50%) 100%);
    }
    
    .camera-btn.active {
      background: linear-gradient(135deg, hsl(142 70% 40%) 0%, hsl(142 70% 35%) 100%);
    }
    
    /* Preview */
    .preview-box {
      width: 100%;
      height: 80px;
      background: hsl(var(--muted));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      margin-top: 8px;
    }
    
    .preview-box img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    .preview-box span {
      font-size: 12px;
      color: hsl(var(--muted-foreground));
    }
    
    /* Hint Text */
    .hint {
      font-size: 11px;
      color: hsl(var(--muted-foreground));
      margin-top: 4px;
    }
    
    /* Sidebar Footer */
    .sidebar-footer {
      padding: 12px;
      border-top: 1px solid hsl(var(--border));
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .sidebar-footer button {
      width: 100%;
    }
    
    /* Main Content */
    #canvas-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: hsl(var(--background));
      position: relative;
    }
    
    /* Stats Bar */
    .stats-bar {
      display: flex;
      gap: 16px;
      padding: 8px 12px;
      background: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      margin-bottom: 12px;
      font-size: 12px;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .stats-bar .stat {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .stats-bar .stat-label {
      color: hsl(var(--muted-foreground));
    }
    
    .stats-bar .stat-value {
      color: hsl(var(--foreground));
      font-weight: 500;
    }
    
    .stats-bar .stat-value.fps {
      color: hsl(142 70% 50%);
    }
    
    /* Canvas Wrapper */
    #canvas-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    canvas {
      border-radius: var(--radius);
      border: 1px solid hsl(var(--border));
      box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
    }
    
    /* 3D Hint */
    .rotate-hint {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: hsl(var(--card));
      border: 1px solid hsl(var(--border));
      border-radius: var(--radius);
      font-size: 12px;
      color: hsl(var(--muted-foreground));
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s;
    }
    
    .rotate-hint.hidden {
      opacity: 0;
    }
    
    .rotate-hint kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 20px;
      padding: 0 6px;
      background: hsl(var(--muted));
      border: 1px solid hsl(var(--border));
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: hsl(var(--foreground));
    }
    
    /* Responsive */
    @media (max-width: 900px) {
      body {
        flex-direction: column-reverse;
      }
      
      #controls {
        width: 100%;
        min-width: 100%;
        height: 50vh;
        border-right: none;
        border-top: 1px solid hsl(var(--border));
      }
      
      #canvas-container {
        height: 50vh;
      }
      
      .rotate-hint {
        bottom: 8px;
        padding: 6px 10px;
      }
    }
    
    @media (max-width: 500px) {
      .sidebar-header {
        padding: 12px;
      }
      
      .sidebar-content {
        padding: 8px;
      }
      
      .preset-grid {
        gap: 4px;
      }
      
      .stats-bar {
        gap: 12px;
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="sidebar-header">
      <div class="logo">
        <div class="logo-icon">◎</div>
        <div>
          <h1>Vectory 3D</h1>
          <p class="logo-subtitle">Particle System</p>
        </div>
      </div>
    </div>
    
    <div class="sidebar-content">
      <button class="camera-btn" id="webcamBtn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>
        Enable Camera
      </button>
      
      <!-- Source Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Source
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Direction Map</label>
            <input type="file" id="imageInput" accept="image/*">
          </div>
          <div class="preview-box" id="imagePreview">
            <span>3D Flow (default)</span>
          </div>
          <p class="hint">RGB channels → XYZ directions</p>
          <div class="preset-grid" style="margin-top: 10px;">
            <button class="outline" id="presetNoise">Noise</button>
            <button class="outline" id="presetGradient">Gradient</button>
            <button class="outline" id="presetRadial">Radial</button>
            <button class="outline" id="preset3DFlow">3D Flow</button>
          </div>
        </div>
      </div>
      
      <!-- Mode Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Mode
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <select id="mode">
              <option value="1">Particles (2D)</option>
              <option value="2">Static Trails (2D)</option>
              <option value="3">Moving Trails (2D)</option>
              <option value="4" selected>Particles (3D)</option>
              <option value="5">Trails (3D)</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- 3D Settings Section -->
      <div class="section" id="section3D">
        <button class="section-trigger" onclick="toggleSection(this)">
          3D Settings
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Spawn Mode</label>
            <select id="spawn3DMode">
              <option value="1">Image Plane</option>
              <option value="2" selected>Depth from Brightness</option>
              <option value="3">Full Volume</option>
            </select>
          </div>
          <div class="control-group">
            <label>Direction Source</label>
            <select id="dir3DSource">
              <option value="1">Brightness → Angle</option>
              <option value="2" selected>RGB → XYZ</option>
            </select>
          </div>
          <div class="control-group">
            <label>Depth Scale <span class="value" id="depthScaleVal">100</span></label>
            <input type="range" id="depthScale" min="10" max="300" value="100">
          </div>
          <div class="control-group">
            <label>Image Attraction <span class="value" id="imgAttrVal">0</span></label>
            <input type="range" id="imgAttr" min="0" max="100" value="0">
          </div>
          <div class="control-group">
            <label>Camera Distance <span class="value" id="camDistVal">700</span></label>
            <input type="range" id="camDist" min="100" max="1000" value="700">
          </div>
          <div class="control-group">
            <label>Field of View <span class="value" id="fovVal">60°</span></label>
            <input type="range" id="fov" min="30" max="120" value="60">
          </div>
        </div>
      </div>
      
      <!-- Spawn Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Spawn
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Seed <span class="value" id="seedVal">1</span></label>
            <input type="range" id="seed" min="1" max="9999" value="1">
          </div>
          <div class="control-group">
            <label>Spawn Type</label>
            <select id="spawnType">
              <option value="1" selected>Random</option>
              <option value="2">On Brightness</option>
            </select>
          </div>
          <div class="control-group">
            <label>Particles/frame <span class="value" id="countVal">1000</span></label>
            <input type="range" id="count" min="1" max="2000" value="1000">
          </div>
          <div class="control-group">
            <label>Brightness Cutoff <span class="value" id="cutoffVal">30%</span></label>
            <input type="range" id="cutoff" min="0" max="99" value="30">
          </div>
        </div>
      </div>
      
      <!-- Particle Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Particle
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Lifetime <span class="value" id="lifetimeVal">100</span></label>
            <input type="range" id="lifetime" min="10" max="500" value="100">
          </div>
          <div class="control-group">
            <label>Size <span class="value" id="sizeVal">3</span></label>
            <input type="range" id="size" min="1" max="30" value="3">
          </div>
          <div class="control-group">
            <label>Speed <span class="value" id="speedVal">2</span></label>
            <input type="range" id="speed" min="0.5" max="20" value="2" step="0.5">
          </div>
        </div>
      </div>
      
      <!-- Direction 2D Section -->
      <div class="section" id="section2DDirection" style="display: none;">
        <button class="section-trigger" onclick="toggleSection(this)">
          Direction (2D)
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Channel</label>
            <select id="channel">
              <option value="1" selected>Brightness</option>
              <option value="2">Red</option>
              <option value="3">Green</option>
              <option value="4">Blue</option>
            </select>
          </div>
          <div class="control-group">
            <label>Direction Shift <span class="value" id="shiftVal">0°</span></label>
            <input type="range" id="shift" min="0" max="360" value="0">
          </div>
          <div class="control-group">
            <label>Fluctuation <span class="value" id="fluctVal">0°</span></label>
            <input type="range" id="fluct" min="0" max="180" value="0">
          </div>
          <div class="control-group">
            <label>Dynamic Fluct. <span class="value" id="dynFluctVal">0°</span></label>
            <input type="range" id="dynFluct" min="0" max="180" value="0">
          </div>
        </div>
      </div>
      
      <!-- Forces Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Forces
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Attraction <span class="value" id="attrForceVal">0</span></label>
            <input type="range" id="attrForce" min="-10" max="10" value="0" step="0.5">
          </div>
          <div class="control-group">
            <label>Angle <span class="value" id="attrAngleVal">0°</span></label>
            <input type="range" id="attrAngle" min="0" max="360" value="0">
          </div>
        </div>
      </div>
      
      <!-- Color Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Color
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <label>Mode</label>
            <select id="colorMode">
              <option value="1" selected>Keep Original</option>
              <option value="2">Sample Position</option>
              <option value="3">Custom</option>
              <option value="4">Lifetime Gradient</option>
              <option value="5">Depth Gradient</option>
            </select>
          </div>
          <div class="control-group">
            <label>Custom Color</label>
            <input type="color" id="customColor" value="#ffffff">
          </div>
          <div class="control-group">
            <label>Start / Near</label>
            <input type="color" id="startColor" value="#ffffff">
          </div>
          <div class="control-group">
            <label>End / Far</label>
            <input type="color" id="endColor" value="#e94560">
          </div>
        </div>
      </div>
      
      <!-- Background Section -->
      <div class="section">
        <button class="section-trigger" onclick="toggleSection(this)">
          Background
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m6 9 6 6 6-6"/></svg>
        </button>
        <div class="section-content">
          <div class="control-group">
            <div class="checkbox-wrapper">
              <input type="checkbox" id="transparentBg" checked>
              <label for="transparentBg">Transparent</label>
            </div>
          </div>
          <div class="control-group">
            <label>Color</label>
            <input type="color" id="bgColor" value="#09090b">
          </div>
          <div class="control-group">
            <label>Trail Fade <span class="value" id="fadeVal">3</span></label>
            <input type="range" id="fade" min="0" max="50" value="3">
          </div>
        </div>
      </div>
    </div>
    
    <div class="sidebar-footer">
      <button class="secondary" id="resetBtn">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        Reset
      </button>
      <button id="saveBtn">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
        Save Image
      </button>
    </div>
  </div>
  
  <div id="canvas-container">
    <div class="stats-bar">
      <div class="stat">
        <span class="stat-label">FPS</span>
        <span class="stat-value fps" id="fpsDisplay">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">Particles</span>
        <span class="stat-value" id="particleCount">0</span>
      </div>
    </div>
    
    <div id="canvas-wrapper">
      <canvas id="glCanvas"></canvas>
      <div class="rotate-hint" id="rotateHint">
        <span>Drag to rotate</span>
        <kbd>Scroll</kbd>
        <span>to zoom</span>
      </div>
    </div>
  </div>

<script>
// Toggle section collapse
function toggleSection(trigger) {
  trigger.parentElement.classList.toggle('collapsed');
}

// ========== Settings ==========
const settings = {
  mode: 4,
  seed: 1,
  spawnType: 1,
  count: 1000,
  cutoff: 30,
  lifetime: 100,
  size: 3,
  speed: 2,
  channel: 1,
  shift: 0,
  fluct: 0,
  dynFluct: 0,
  attrForce: 0,
  attrAngle: 0,
  colorMode: 1,
  customColor: '#ffffff',
  startColor: '#ffffff',
  endColor: '#e94560',
  transparentBg: true,
  bgColor: '#09090b',
  fade: 3,
  camDist: 700,
  fov: 60,
  depthScale: 100,
  spawn3DMode: 2,
  dir3DSource: 2,
  imgAttr: 0
};

// ========== WebGL State ==========
let gl, canvas;
let canvasWidth = 1280, canvasHeight = 720;
let program, trailProgram;
let positionBuffer, colorBuffer, sizeBuffer;
let uProjection, uView, uResolution, uIs3D;

const MAX_PARTICLES = 200000;
let particleCount = 0;
let positions = new Float32Array(MAX_PARTICLES * 3);
let colors = new Float32Array(MAX_PARTICLES * 4);
let sizes = new Float32Array(MAX_PARTICLES);
let velocities = new Float32Array(MAX_PARTICLES * 3);
let lifetimes = new Float32Array(MAX_PARTICLES);
let maxLifetimes = new Float32Array(MAX_PARTICLES);
let origPositions = new Float32Array(MAX_PARTICLES * 3);
let particleFluct = new Float32Array(MAX_PARTICLES);
let particleIds = new Uint32Array(MAX_PARTICLES);
let particleIdCounter = 0;

let trailPositions = new Float32Array(MAX_PARTICLES * 50 * 3);
let trailColors = new Float32Array(MAX_PARTICLES * 50 * 4);
let trailCounts = new Uint16Array(MAX_PARTICLES);
const TRAIL_LENGTH = 30;
let particleSpeeds = new Float32Array(MAX_PARTICLES);

let sourceData = null, sourceWidth = 0, sourceHeight = 0;
let camRotX = 0.3, camRotY = 0;
let isDragging = false, lastMouseX = 0, lastMouseY = 0;
let webcam = null, useWebcam = false;
let frameCount = 0, lastTime = performance.now(), fps = 0;
let hintInteracted = false;

let brightnessSamples = [];
let brightnessSamplerReady = false;

// ========== Hash Functions ==========
function hash2(a, b) {
  let x = (a * 374761393 + b * 668265263) | 0;
  x = ((x >>> 16) ^ x) * 0x45d9f3b | 0;
  x = ((x >>> 16) ^ x) * 0x45d9f3b | 0;
  return (x >>> 16) ^ x;
}

function hashFloat2(a, b) { return (hash2(a, b) >>> 0) / 4294967296; }
function hashRange(a, b, min, max) { return min + hashFloat2(a, b) * (max - min); }
function hashFluct(a, b) { return (hash2(a, b) % 257) - 128; }

function buildBrightnessSampler() {
  if (!sourceData) return;
  const cutoffThreshold = settings.cutoff * 2.55;
  brightnessSamples = [];
  const step = Math.max(1, Math.floor(Math.min(sourceWidth, sourceHeight) / 128));
  for (let y = 0; y < sourceHeight; y += step) {
    for (let x = 0; x < sourceWidth; x += step) {
      const idx = (y * sourceWidth + x) * 4;
      const brightness = 0.2126 * sourceData[idx] + 0.7152 * sourceData[idx + 1] + 0.0722 * sourceData[idx + 2];
      if (brightness >= cutoffThreshold) {
        brightnessSamples.push({ x: (x / sourceWidth) * canvasWidth, y: (y / sourceHeight) * canvasHeight, brightness });
      }
    }
  }
  brightnessSamplerReady = brightnessSamples.length > 0;
}

// ========== Shaders ==========
const vertexShaderSource = `
  attribute vec3 aPosition;
  attribute vec4 aColor;
  attribute float aSize;
  uniform mat4 uProjection;
  uniform mat4 uView;
  uniform vec2 uResolution;
  uniform float uIs3D;
  varying vec4 vColor;
  void main() {
    vec4 viewPos = uView * vec4(aPosition, 1.0);
    gl_Position = uProjection * viewPos;
    if (uIs3D > 0.5) {
      float dist = length(viewPos.xyz);
      gl_PointSize = clamp(aSize * (uResolution.y / dist) * 0.5, 1.0, 100.0);
    } else {
      gl_PointSize = aSize;
    }
    vColor = aColor;
  }
`;

const fragmentShaderSource = `
  precision mediump float;
  varying vec4 vColor;
  void main() {
    vec2 coord = gl_PointCoord - vec2(0.5);
    float dist = length(coord);
    if (dist > 0.5) discard;
    float alpha = smoothstep(0.5, 0.3, dist) * vColor.a;
    gl_FragColor = vec4(vColor.rgb, alpha);
  }
`;

// ========== Matrix Functions ==========
function perspectiveMatrix(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov * Math.PI / 360);
  const nf = 1 / (near - far);
  return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
}

function orthoMatrix(left, right, bottom, top, near, far) {
  return new Float32Array([2/(right-left),0,0,0, 0,2/(top-bottom),0,0, 0,0,-2/(far-near),0, -(right+left)/(right-left),-(top+bottom)/(top-bottom),-(far+near)/(far-near),1]);
}

function viewMatrix(rotX, rotY, dist) {
  const cx = Math.cos(rotX), sx = Math.sin(rotX), cy = Math.cos(rotY), sy = Math.sin(rotY);
  return new Float32Array([cy,sx*sy,-cx*sy,0, 0,cx,sx,0, sy,-sx*cy,cx*cy,0, 0,0,-dist,1]);
}

function identityMatrix() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }

// ========== WebGL Init ==========
function initWebGL() {
  canvas = document.getElementById('glCanvas');
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  gl = canvas.getContext('webgl', { alpha: false, antialias: true, preserveDrawingBuffer: true });
  if (!gl) { alert('WebGL not supported'); return false; }
  
  program = createProgram(vertexShaderSource, fragmentShaderSource);
  positionBuffer = gl.createBuffer();
  colorBuffer = gl.createBuffer();
  sizeBuffer = gl.createBuffer();
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.useProgram(program);
  uProjection = gl.getUniformLocation(program, 'uProjection');
  uView = gl.getUniformLocation(program, 'uView');
  uResolution = gl.getUniformLocation(program, 'uResolution');
  uIs3D = gl.getUniformLocation(program, 'uIs3D');
  return true;
}

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)); return null; }
  return shader;
}

function createProgram(vsSource, fsSource) {
  const prog = gl.createProgram();
  gl.attachShader(prog, createShader(gl.VERTEX_SHADER, vsSource));
  gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, fsSource));
  gl.linkProgram(prog);
  return prog;
}

// ========== Source Image ==========
function getSourcePixel(x, y) {
  if (!sourceData) return { r: 128, g: 128, b: 128 };
  const sx = Math.floor((x / canvasWidth) * sourceWidth);
  const sy = Math.floor(((canvasHeight - y) / canvasHeight) * sourceHeight);
  const cx = Math.max(0, Math.min(sourceWidth - 1, sx));
  const cy = Math.max(0, Math.min(sourceHeight - 1, sy));
  const idx = (cy * sourceWidth + cx) * 4;
  return { r: sourceData[idx], g: sourceData[idx + 1], b: sourceData[idx + 2] };
}

function getBrightness(x, y) {
  const p = getSourcePixel(x, y);
  return 0.2126 * p.r + 0.7152 * p.g + 0.0722 * p.b;
}

// ========== Particle System ==========
function spawnParticle(index) {
  const seed = settings.seed;
  const key = seed * 100000 + frameCount * 1000 + index;
  const pId = particleIdCounter++;
  
  let spawnX, spawnY;
  if (settings.spawnType === 2 && brightnessSamplerReady) {
    const sample = brightnessSamples[Math.floor(hashFloat2(key, 100) * brightnessSamples.length)];
    spawnX = sample.x; spawnY = sample.y;
  } else {
    spawnX = hashRange(key, 1, 0, canvasWidth);
    spawnY = hashRange(key, 2, 0, canvasHeight);
  }
  
  const brightness = getBrightness(spawnX, spawnY);
  const x = spawnX - canvasWidth / 2;
  const y = spawnY - canvasHeight / 2;
  
  let z = 0;
  if (settings.mode >= 4) {
    switch (settings.spawn3DMode) {
      case 1: z = 0; break;
      case 2: z = (brightness / 255 - 0.5) * settings.depthScale * 2; break;
      case 3: z = hashRange(key, 3, -settings.depthScale, settings.depthScale); break;
    }
  }
  
  const pixel = getSourcePixel(spawnX, spawnY);
  let channelValue;
  switch (settings.channel) {
    case 1: channelValue = brightness; break;
    case 2: channelValue = pixel.r; break;
    case 3: channelValue = pixel.g; break;
    case 4: channelValue = pixel.b; break;
    default: channelValue = brightness;
  }
  
  const normalizedFluct = Math.round(settings.fluct * 0.708);
  const lineFluct = normalizedFluct > 0 ? Math.floor(hashFluct(pId, 2) * normalizedFluct / 128) : 0;
  const speed = settings.speed * (0.5 + hashFloat2(key, 4) * 0.5);
  
  let vx, vy, vz;
  if (settings.dir3DSource === 2 && settings.mode >= 4) {
    vx = (pixel.r / 127.5 - 1) * speed;
    vy = (pixel.g / 127.5 - 1) * speed;
    vz = (pixel.b / 127.5 - 1) * speed;
  } else {
    const angle = (channelValue / 255) * Math.PI * 2 + settings.shift * Math.PI / 180 + lineFluct * Math.PI / 180;
    vx = Math.cos(angle) * speed;
    vy = Math.sin(angle) * speed;
    vz = 0;
  }
  
  const i3 = particleCount * 3, i4 = particleCount * 4;
  positions[i3] = x; positions[i3+1] = y; positions[i3+2] = z;
  origPositions[i3] = x; origPositions[i3+1] = y; origPositions[i3+2] = z;
  velocities[i3] = vx; velocities[i3+1] = vy; velocities[i3+2] = vz;
  particleFluct[particleCount] = lineFluct;
  particleIds[particleCount] = pId;
  particleSpeeds[particleCount] = speed;
  
  if (settings.colorMode === 1 || settings.colorMode === 2) {
    colors[i4] = pixel.r/255; colors[i4+1] = pixel.g/255; colors[i4+2] = pixel.b/255;
  } else if (settings.colorMode === 3) {
    const c = hexToRgb(settings.customColor);
    colors[i4] = c.r/255; colors[i4+1] = c.g/255; colors[i4+2] = c.b/255;
  } else {
    const c = hexToRgb(settings.startColor);
    colors[i4] = c.r/255; colors[i4+1] = c.g/255; colors[i4+2] = c.b/255;
  }
  colors[i4+3] = 1.0;
  sizes[particleCount] = settings.size;
  lifetimes[particleCount] = settings.lifetime;
  maxLifetimes[particleCount] = settings.lifetime;
  trailCounts[particleCount] = 0;
  particleCount++;
}

function updateParticles() {
  let writeIdx = 0;
  const attrRad = settings.attrAngle * Math.PI / 180;
  const attrCos = Math.cos(attrRad), attrSin = Math.sin(attrRad);
  let gradientC1 = null, gradientC2 = null;
  if (settings.colorMode === 4 || settings.colorMode === 5) {
    gradientC1 = hexToRgb(settings.startColor);
    gradientC2 = hexToRgb(settings.endColor);
  }
  
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3, i4 = i * 4;
    lifetimes[i]--;
    if (lifetimes[i] <= 0) continue;
    
    const canvasX = positions[i3] + canvasWidth / 2;
    const canvasY = positions[i3 + 1] + canvasHeight / 2;
    const pId = particleIds[i];
    const step = Math.floor(maxLifetimes[i] - lifetimes[i]);
    const speed = particleSpeeds[i];
    
    if (settings.dir3DSource === 2 && settings.mode >= 4) {
      const pixel = getSourcePixel(canvasX, canvasY);
      velocities[i3] = (pixel.r / 127.5 - 1) * speed;
      velocities[i3+1] = (pixel.g / 127.5 - 1) * speed;
      velocities[i3+2] = (pixel.b / 127.5 - 1) * speed;
    } else {
      const pixel = getSourcePixel(canvasX, canvasY);
      const brightness = 0.2126 * pixel.r + 0.7152 * pixel.g + 0.0722 * pixel.b;
      let channelValue;
      switch (settings.channel) {
        case 1: channelValue = brightness; break;
        case 2: channelValue = pixel.r; break;
        case 3: channelValue = pixel.g; break;
        case 4: channelValue = pixel.b; break;
        default: channelValue = brightness;
      }
      let dynFluctVal = 0;
      if (settings.dynFluct > 0) {
        const normalizedDynFluct = Math.round(settings.dynFluct * 0.708);
        dynFluctVal = Math.floor(hashFluct(pId * 10000 + step, 3) * normalizedDynFluct / 128);
      }
      const angle = (channelValue / 255) * Math.PI * 2 + settings.shift * Math.PI / 180 + particleFluct[i] * Math.PI / 180 + dynFluctVal * Math.PI / 180;
      velocities[i3] = Math.cos(angle) * speed;
      velocities[i3+1] = Math.sin(angle) * speed;
    }
    
    if (settings.attrForce !== 0) {
      velocities[i3] += attrCos * settings.attrForce * 0.1;
      velocities[i3+1] += attrSin * settings.attrForce * 0.1;
    }
    
    if (settings.imgAttr > 0 && settings.mode >= 4) {
      const strength = settings.imgAttr * 0.001;
      velocities[i3] += (origPositions[i3] - positions[i3]) * strength;
      velocities[i3+1] += (origPositions[i3+1] - positions[i3+1]) * strength;
      velocities[i3+2] += (origPositions[i3+2] - positions[i3+2]) * strength;
    }
    
    if (settings.mode === 5 || settings.mode === 3) {
      const trailBase = i * TRAIL_LENGTH;
      if (trailCounts[i] >= TRAIL_LENGTH) {
        for (let t = 0; t < TRAIL_LENGTH - 1; t++) {
          const srcIdx = trailBase + t + 1, dstIdx = trailBase + t;
          trailPositions[dstIdx*3] = trailPositions[srcIdx*3];
          trailPositions[dstIdx*3+1] = trailPositions[srcIdx*3+1];
          trailPositions[dstIdx*3+2] = trailPositions[srcIdx*3+2];
          trailColors[dstIdx*4] = trailColors[srcIdx*4];
          trailColors[dstIdx*4+1] = trailColors[srcIdx*4+1];
          trailColors[dstIdx*4+2] = trailColors[srcIdx*4+2];
          trailColors[dstIdx*4+3] = trailColors[srcIdx*4+3];
        }
        trailCounts[i] = TRAIL_LENGTH - 1;
      }
      const trailIdx = trailBase + trailCounts[i];
      trailPositions[trailIdx*3] = positions[i3];
      trailPositions[trailIdx*3+1] = positions[i3+1];
      trailPositions[trailIdx*3+2] = positions[i3+2];
      trailColors[trailIdx*4] = colors[i4];
      trailColors[trailIdx*4+1] = colors[i4+1];
      trailColors[trailIdx*4+2] = colors[i4+2];
      trailColors[trailIdx*4+3] = 1.0;
      trailCounts[i]++;
      for (let t = 0; t < trailCounts[i]; t++) {
        trailColors[(trailBase + t) * 4 + 3] = ((t + 1) / trailCounts[i]) * 0.8;
      }
    }
    
    positions[i3] += velocities[i3];
    positions[i3+1] += velocities[i3+1];
    positions[i3+2] += velocities[i3+2];
    
    const halfWidth = canvasWidth / 2 * 1.5, halfHeight = canvasHeight / 2 * 1.5, maxDepth = settings.depthScale * 2;
    if (Math.abs(positions[i3]) > halfWidth || Math.abs(positions[i3+1]) > halfHeight || Math.abs(positions[i3+2]) > maxDepth) continue;
    
    const lifeRatio = lifetimes[i] / maxLifetimes[i];
    colors[i4+3] = lifeRatio;
    
    if (settings.colorMode === 2) {
      const pixel = getSourcePixel(canvasX, canvasY);
      colors[i4] = pixel.r/255; colors[i4+1] = pixel.g/255; colors[i4+2] = pixel.b/255;
    } else if (settings.colorMode === 4) {
      const t = 1 - lifeRatio;
      colors[i4] = (gradientC1.r + (gradientC2.r - gradientC1.r) * t) / 255;
      colors[i4+1] = (gradientC1.g + (gradientC2.g - gradientC1.g) * t) / 255;
      colors[i4+2] = (gradientC1.b + (gradientC2.b - gradientC1.b) * t) / 255;
    } else if (settings.colorMode === 5) {
      const zNorm = (positions[i3+2] + settings.depthScale) / (settings.depthScale * 2);
      const t = Math.max(0, Math.min(1, zNorm));
      colors[i4] = (gradientC1.r + (gradientC2.r - gradientC1.r) * t) / 255;
      colors[i4+1] = (gradientC1.g + (gradientC2.g - gradientC1.g) * t) / 255;
      colors[i4+2] = (gradientC1.b + (gradientC2.b - gradientC1.b) * t) / 255;
    }
    
    if (writeIdx !== i) {
      const w3 = writeIdx * 3, w4 = writeIdx * 4;
      positions[w3] = positions[i3]; positions[w3+1] = positions[i3+1]; positions[w3+2] = positions[i3+2];
      origPositions[w3] = origPositions[i3]; origPositions[w3+1] = origPositions[i3+1]; origPositions[w3+2] = origPositions[i3+2];
      velocities[w3] = velocities[i3]; velocities[w3+1] = velocities[i3+1]; velocities[w3+2] = velocities[i3+2];
      colors[w4] = colors[i4]; colors[w4+1] = colors[i4+1]; colors[w4+2] = colors[i4+2]; colors[w4+3] = colors[i4+3];
      sizes[writeIdx] = sizes[i]; lifetimes[writeIdx] = lifetimes[i]; maxLifetimes[writeIdx] = maxLifetimes[i];
      particleFluct[writeIdx] = particleFluct[i]; particleIds[writeIdx] = particleIds[i]; particleSpeeds[writeIdx] = particleSpeeds[i];
      const srcTrailBase = i * TRAIL_LENGTH, dstTrailBase = writeIdx * TRAIL_LENGTH;
      for (let t = 0; t < trailCounts[i]; t++) {
        trailPositions[(dstTrailBase+t)*3] = trailPositions[(srcTrailBase+t)*3];
        trailPositions[(dstTrailBase+t)*3+1] = trailPositions[(srcTrailBase+t)*3+1];
        trailPositions[(dstTrailBase+t)*3+2] = trailPositions[(srcTrailBase+t)*3+2];
        trailColors[(dstTrailBase+t)*4] = trailColors[(srcTrailBase+t)*4];
        trailColors[(dstTrailBase+t)*4+1] = trailColors[(srcTrailBase+t)*4+1];
        trailColors[(dstTrailBase+t)*4+2] = trailColors[(srcTrailBase+t)*4+2];
        trailColors[(dstTrailBase+t)*4+3] = trailColors[(srcTrailBase+t)*4+3];
      }
      trailCounts[writeIdx] = trailCounts[i];
    }
    writeIdx++;
  }
  particleCount = writeIdx;
}

// ========== Rendering ==========
function render() {
  const bg = hexToRgb(settings.bgColor);
  if ((settings.mode === 3 || settings.mode === 5) && settings.fade > 0) {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(settings.transparentBg ? 0 : bg.r/255, settings.transparentBg ? 0 : bg.g/255, settings.transparentBg ? 0 : bg.b/255, settings.transparentBg ? 0 : settings.fade/255);
    gl.clear(gl.COLOR_BUFFER_BIT);
  } else {
    gl.clearColor(settings.transparentBg ? 0 : bg.r/255, settings.transparentBg ? 0 : bg.g/255, settings.transparentBg ? 0 : bg.b/255, settings.transparentBg ? 0 : 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }
  
  if (particleCount === 0) return;
  gl.useProgram(program);
  
  let proj, view;
  if (settings.mode >= 4) {
    proj = perspectiveMatrix(settings.fov, canvasWidth/canvasHeight, 1, 5000);
    view = viewMatrix(camRotX, camRotY, settings.camDist);
  } else {
    proj = orthoMatrix(-canvasWidth/2, canvasWidth/2, -canvasHeight/2, canvasHeight/2, -1000, 1000);
    view = identityMatrix();
  }
  
  gl.uniformMatrix4fv(uProjection, false, proj);
  gl.uniformMatrix4fv(uView, false, view);
  gl.uniform2f(uResolution, canvasWidth, canvasHeight);
  gl.uniform1f(uIs3D, settings.mode >= 4 ? 1.0 : 0.0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions.subarray(0, particleCount * 3), gl.DYNAMIC_DRAW);
  const aPosition = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(aPosition);
  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, colors.subarray(0, particleCount * 4), gl.DYNAMIC_DRAW);
  const aColor = gl.getAttribLocation(program, 'aColor');
  gl.enableVertexAttribArray(aColor);
  gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, sizes.subarray(0, particleCount), gl.DYNAMIC_DRAW);
  const aSize = gl.getAttribLocation(program, 'aSize');
  gl.enableVertexAttribArray(aSize);
  gl.vertexAttribPointer(aSize, 1, gl.FLOAT, false, 0, 0);
  
  gl.drawArrays(gl.POINTS, 0, particleCount);
  
  if (settings.mode === 3 || settings.mode === 5) renderTrails3D(proj, view);
}

function renderTrails3D(proj, view) {
  if (particleCount === 0) return;
  gl.useProgram(program);
  gl.uniformMatrix4fv(uProjection, false, proj);
  gl.uniformMatrix4fv(uView, false, view);
  gl.uniform2f(uResolution, canvasWidth, canvasHeight);
  gl.uniform1f(uIs3D, settings.mode >= 4 ? 1.0 : 0.0);
  
  let totalPoints = 0;
  for (let i = 0; i < particleCount; i++) totalPoints += trailCounts[i];
  if (totalPoints === 0) return;
  
  const trailPos = new Float32Array(totalPoints * 3);
  const trailCol = new Float32Array(totalPoints * 4);
  const trailSiz = new Float32Array(totalPoints);
  let vertIdx = 0;
  
  for (let i = 0; i < particleCount; i++) {
    const count = trailCounts[i];
    if (count === 0) continue;
    const baseIdx = i * TRAIL_LENGTH;
    for (let j = 0; j < count; j++) {
      const idx = baseIdx + j;
      trailPos[vertIdx*3] = trailPositions[idx*3];
      trailPos[vertIdx*3+1] = trailPositions[idx*3+1];
      trailPos[vertIdx*3+2] = trailPositions[idx*3+2];
      trailCol[vertIdx*4] = trailColors[idx*4];
      trailCol[vertIdx*4+1] = trailColors[idx*4+1];
      trailCol[vertIdx*4+2] = trailColors[idx*4+2];
      trailCol[vertIdx*4+3] = trailColors[idx*4+3];
      trailSiz[vertIdx] = settings.size * 0.7;
      vertIdx++;
    }
  }
  
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailPos.subarray(0, vertIdx * 3), gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailCol.subarray(0, vertIdx * 4), gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailSiz.subarray(0, vertIdx), gl.DYNAMIC_DRAW);
  gl.drawArrays(gl.POINTS, 0, vertIdx);
}

function renderStaticTrails() {
  const bg = hexToRgb(settings.bgColor);
  gl.clearColor(settings.transparentBg ? 0 : bg.r/255, settings.transparentBg ? 0 : bg.g/255, settings.transparentBg ? 0 : bg.b/255, settings.transparentBg ? 0 : 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);
  
  const proj = orthoMatrix(-canvasWidth/2, canvasWidth/2, -canvasHeight/2, canvasHeight/2, -1000, 1000);
  const view = identityMatrix();
  gl.uniformMatrix4fv(uProjection, false, proj);
  gl.uniformMatrix4fv(uView, false, view);
  gl.uniform2f(uResolution, canvasWidth, canvasHeight);
  gl.uniform1f(uIs3D, 0.0);
  
  const attrRad = settings.attrAngle * Math.PI / 180;
  const attrCos = Math.cos(attrRad), attrSin = Math.sin(attrRad);
  const gradientC1 = hexToRgb(settings.startColor);
  const gradientC2 = hexToRgb(settings.endColor);
  const customC = hexToRgb(settings.customColor);
  
  const maxSteps = Math.floor(settings.lifetime * settings.speed);
  const totalPoints = settings.count * maxSteps;
  const trailPos = new Float32Array(totalPoints * 3);
  const trailCol = new Float32Array(totalPoints * 4);
  const trailSiz = new Float32Array(totalPoints);
  let pointIdx = 0;
  
  for (let i = 0; i < settings.count; i++) {
    const key = settings.seed * 10000 + i;
    let spawnX, spawnY;
    if (settings.spawnType === 2 && brightnessSamplerReady) {
      const sample = brightnessSamples[Math.floor(hashFloat2(key, 100) * brightnessSamples.length)];
      spawnX = sample.x; spawnY = sample.y;
    } else {
      spawnX = hashRange(key, 1, 0, canvasWidth);
      spawnY = hashRange(key, 2, 0, canvasHeight);
    }
    
    let x = spawnX - canvasWidth / 2, y = spawnY - canvasHeight / 2;
    const startPixel = getSourcePixel(spawnX, spawnY);
    const speed = settings.speed * (0.5 + hashFloat2(key, 3) * 0.5);
    const normalizedFluct = Math.round(settings.fluct * 0.708);
    const lineFluct = normalizedFluct > 0 ? Math.floor(hashFluct(key, 2) * normalizedFluct / 128) : 0;
    const fluctRad = lineFluct * Math.PI / 180;
    const shiftRad = settings.shift * Math.PI / 180;
    
    for (let step = 0; step < maxSteps; step++) {
      const canvasX = x + canvasWidth / 2, canvasY = y + canvasHeight / 2;
      if (canvasX < 0 || canvasX >= canvasWidth || canvasY < 0 || canvasY >= canvasHeight) break;
      
      const pixel = getSourcePixel(canvasX, canvasY);
      const brightness = 0.2126 * pixel.r + 0.7152 * pixel.g + 0.0722 * pixel.b;
      let channelValue;
      switch (settings.channel) {
        case 1: channelValue = brightness; break;
        case 2: channelValue = pixel.r; break;
        case 3: channelValue = pixel.g; break;
        case 4: channelValue = pixel.b; break;
        default: channelValue = brightness;
      }
      
      let dynFluctVal = 0;
      if (settings.dynFluct > 0) {
        const normalizedDynFluct = Math.round(settings.dynFluct * 0.708);
        dynFluctVal = Math.floor(hashFluct(key * 10000 + step, 3) * normalizedDynFluct / 128);
      }
      const angle = (channelValue / 255) * Math.PI * 2 + shiftRad + fluctRad + dynFluctVal * Math.PI / 180;
      
      trailPos[pointIdx*3] = x; trailPos[pointIdx*3+1] = y; trailPos[pointIdx*3+2] = 0;
      const t = step / maxSteps;
      if (settings.colorMode === 1) {
        trailCol[pointIdx*4] = startPixel.r/255; trailCol[pointIdx*4+1] = startPixel.g/255; trailCol[pointIdx*4+2] = startPixel.b/255;
      } else if (settings.colorMode === 2) {
        trailCol[pointIdx*4] = pixel.r/255; trailCol[pointIdx*4+1] = pixel.g/255; trailCol[pointIdx*4+2] = pixel.b/255;
      } else if (settings.colorMode === 4) {
        trailCol[pointIdx*4] = (gradientC1.r + (gradientC2.r - gradientC1.r) * t) / 255;
        trailCol[pointIdx*4+1] = (gradientC1.g + (gradientC2.g - gradientC1.g) * t) / 255;
        trailCol[pointIdx*4+2] = (gradientC1.b + (gradientC2.b - gradientC1.b) * t) / 255;
      } else {
        trailCol[pointIdx*4] = customC.r/255; trailCol[pointIdx*4+1] = customC.g/255; trailCol[pointIdx*4+2] = customC.b/255;
      }
      trailCol[pointIdx*4+3] = 1 - t;
      trailSiz[pointIdx] = settings.size;
      pointIdx++;
      
      let vx = Math.cos(angle) * speed, vy = Math.sin(angle) * speed;
      if (settings.attrForce !== 0) { vx += attrCos * settings.attrForce * 0.1; vy += attrSin * settings.attrForce * 0.1; }
      x += vx; y += vy;
    }
  }
  
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailPos.subarray(0, pointIdx * 3), gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailCol.subarray(0, pointIdx * 4), gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, trailSiz.subarray(0, pointIdx), gl.DYNAMIC_DRAW);
  gl.drawArrays(gl.POINTS, 0, pointIdx);
}

// ========== Main Loop ==========
function mainLoop() {
  frameCount++;
  const now = performance.now();
  if (now - lastTime >= 500) {
    fps = Math.round(frameCount / ((now - lastTime) / 1000));
    document.getElementById('fpsDisplay').textContent = fps;
    document.getElementById('particleCount').textContent = particleCount;
    frameCount = 0;
    lastTime = now;
  }
  
  if (useWebcam) updateFromWebcam();
  
  if (settings.mode === 2) {
    renderStaticTrails();
  } else {
    const spawnCount = Math.min(settings.count, MAX_PARTICLES - particleCount);
    for (let i = 0; i < spawnCount; i++) spawnParticle(i);
    updateParticles();
    render();
  }
  
  requestAnimationFrame(mainLoop);
}

// ========== Helpers ==========
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 255, g: 255, b: 255 };
}

// ========== Direction Maps ==========
function noiseHash(x, y, seed) { let n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453; return n - Math.floor(n); }
function smoothNoise(x, y, seed) {
  const ix = Math.floor(x), iy = Math.floor(y), fx = x - ix, fy = y - iy;
  const a = noiseHash(ix, iy, seed), b = noiseHash(ix + 1, iy, seed), c = noiseHash(ix, iy + 1, seed), d = noiseHash(ix + 1, iy + 1, seed);
  const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);
  return a * (1 - ux) * (1 - uy) + b * ux * (1 - uy) + c * (1 - ux) * uy + d * ux * uy;
}
function fractalNoise(x, y, seed, octaves = 4) {
  let val = 0, amp = 0.5, freq = 1, max = 0;
  for (let i = 0; i < octaves; i++) { val += smoothNoise(x * freq, y * freq, seed + i * 100) * amp; max += amp; amp *= 0.5; freq *= 2; }
  return val / max;
}

function createNoiseMap() {
  const width = 512, height = 288, data = new Uint8Array(width * height * 4), scale = 0.02;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      data[idx] = Math.floor(fractalNoise(x * scale, y * scale, settings.seed) * 255);
      data[idx + 1] = Math.floor(fractalNoise(x * scale, y * scale, settings.seed + 1000) * 255);
      data[idx + 2] = Math.floor(fractalNoise(x * scale, y * scale, settings.seed + 2000) * 255);
      data[idx + 3] = 255;
    }
  }
  sourceData = data; sourceWidth = width; sourceHeight = height;
  updateCanvasSize(); updatePreview();
}

function createGradientMap() {
  const width = 512, height = 288, data = new Uint8Array(width * height * 4);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4, val = Math.floor((x / width) * 255);
      data[idx] = val; data[idx + 1] = val; data[idx + 2] = val; data[idx + 3] = 255;
    }
  }
  sourceData = data; sourceWidth = width; sourceHeight = height;
  updateCanvasSize(); updatePreview();
}

function createRadialMap() {
  const width = 512, height = 288, data = new Uint8Array(width * height * 4), cx = width / 2, cy = height / 2;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4, dx = x - cx, dy = y - cy, len = Math.sqrt(dx * dx + dy * dy) || 1;
      data[idx] = Math.floor((dx / len * 0.5 + 0.5) * 255);
      data[idx + 1] = Math.floor((dy / len * 0.5 + 0.5) * 255);
      data[idx + 2] = Math.floor(0.6 * 255);
      data[idx + 3] = 255;
    }
  }
  sourceData = data; sourceWidth = width; sourceHeight = height;
  updateCanvasSize(); updatePreview();
}

function create3DFlowMap() {
  const width = 512, height = 288, data = new Uint8Array(width * height * 4), cx = width / 2, cy = height / 2, maxDist = Math.min(width, height) * 0.5;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4, dx = x - cx, dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy) / maxDist, angle = Math.atan2(dy, dx);
      const tangentX = -Math.sin(angle), tangentY = Math.cos(angle);
      const turbulence = fractalNoise(x * 0.02, y * 0.02, settings.seed, 3);
      const zFlow = Math.sin(dist * 4 + settings.seed * 0.1) * 0.5;
      const vx = tangentX * 0.7 + (turbulence - 0.5) * 0.6, vy = tangentY * 0.7 + (turbulence - 0.5) * 0.6;
      data[idx] = Math.floor((vx * 0.5 + 0.5) * 255);
      data[idx + 1] = Math.floor((vy * 0.5 + 0.5) * 255);
      data[idx + 2] = Math.floor((zFlow * 0.5 + 0.5) * 255);
      data[idx + 3] = 255;
    }
  }
  sourceData = data; sourceWidth = width; sourceHeight = height;
  updateCanvasSize(); updatePreview();
}

function updatePreview() {
  if (!sourceData) return;
  const container = document.getElementById('imagePreview');
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceWidth; tempCanvas.height = sourceHeight;
  const ctx = tempCanvas.getContext('2d');
  const imgData = ctx.createImageData(sourceWidth, sourceHeight);
  imgData.data.set(sourceData);
  ctx.putImageData(imgData, 0, 0);
  container.innerHTML = '';
  const img = document.createElement('img');
  img.src = tempCanvas.toDataURL();
  container.appendChild(img);
}

// ========== Webcam ==========
async function startWebcam() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 256 }, height: { ideal: 256 }, facingMode: 'user' }, audio: false });
    webcam = document.createElement('video');
    webcam.srcObject = stream;
    webcam.setAttribute('playsinline', '');
    webcam.muted = true;
    await webcam.play();
    useWebcam = true;
    sourceWidth = 256; sourceHeight = 256;
    updateCanvasSize();
    const btn = document.getElementById('webcamBtn');
    btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg> Camera Active';
    btn.classList.add('active');
    document.getElementById('imagePreview').innerHTML = '<span>📷 Live Feed</span>';
  } catch (err) { alert('Could not access webcam: ' + err.message); }
}

function stopWebcam() {
  if (webcam) { const stream = webcam.srcObject; if (stream) stream.getTracks().forEach(t => t.stop()); webcam.srcObject = null; webcam = null; }
  useWebcam = false;
  const btn = document.getElementById('webcamBtn');
  btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg> Enable Camera';
  btn.classList.remove('active');
}

function updateFromWebcam() {
  if (!webcam || !useWebcam) return;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = 256; tempCanvas.height = 256;
  const ctx = tempCanvas.getContext('2d');
  ctx.translate(256, 0); ctx.scale(-1, 1);
  ctx.drawImage(webcam, 0, 0, 256, 256);
  const imgData = ctx.getImageData(0, 0, 256, 256);
  sourceData = new Uint8Array(imgData.data);
  sourceWidth = 256; sourceHeight = 256;
}

// ========== Hint ==========
function updateHintVisibility() {
  const hint = document.getElementById('rotateHint');
  if (settings.mode >= 4 && !hintInteracted) hint.classList.remove('hidden');
  else hint.classList.add('hidden');
}

function hideHintOnInteraction() { if (!hintInteracted) { hintInteracted = true; updateHintVisibility(); } }

// ========== Mouse Controls ==========
function setupMouseControls() {
  canvas.addEventListener('mousedown', (e) => { if (settings.mode >= 4) { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; hideHintOnInteraction(); } });
  document.addEventListener('mouseup', () => { isDragging = false; });
  document.addEventListener('mousemove', (e) => {
    if (isDragging && settings.mode >= 4) {
      camRotY += (e.clientX - lastMouseX) * 0.01;
      camRotX += (e.clientY - lastMouseY) * 0.01;
      camRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camRotX));
      lastMouseX = e.clientX; lastMouseY = e.clientY;
    }
  });
  canvas.addEventListener('touchstart', (e) => { if (settings.mode >= 4 && e.touches.length === 1) { isDragging = true; lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY; hideHintOnInteraction(); } }, { passive: true });
  canvas.addEventListener('touchmove', (e) => {
    if (isDragging && settings.mode >= 4 && e.touches.length === 1) {
      camRotY += (e.touches[0].clientX - lastMouseX) * 0.01;
      camRotX += (e.touches[0].clientY - lastMouseY) * 0.01;
      camRotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camRotX));
      lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY;
    }
  }, { passive: true });
  canvas.addEventListener('touchend', () => { isDragging = false; });
  canvas.addEventListener('wheel', (e) => {
    if (settings.mode >= 4) {
      e.preventDefault(); hideHintOnInteraction();
      settings.camDist = Math.max(100, Math.min(1000, settings.camDist * (e.deltaY > 0 ? 1.1 : 0.9)));
      document.getElementById('camDist').value = Math.round(settings.camDist);
      document.getElementById('camDistVal').textContent = Math.round(settings.camDist);
    }
  }, { passive: false });
}

// ========== UI Controls ==========
function setupControls() {
  const updateDisplay = (id, suffix = '') => { const el = document.getElementById(id); const val = document.getElementById(id + 'Val'); if (val) val.textContent = el.value + suffix; };
  
  document.getElementById('presetNoise').addEventListener('click', () => { stopWebcam(); createNoiseMap(); resetParticles(); });
  document.getElementById('presetGradient').addEventListener('click', () => { stopWebcam(); createGradientMap(); resetParticles(); });
  document.getElementById('presetRadial').addEventListener('click', () => { stopWebcam(); createRadialMap(); resetParticles(); });
  document.getElementById('preset3DFlow').addEventListener('click', () => { stopWebcam(); create3DFlowMap(); resetParticles(); });
  document.getElementById('webcamBtn').addEventListener('click', () => { if (useWebcam) { stopWebcam(); create3DFlowMap(); } else startWebcam(); });
  
  function update2DDirectionVisibility() {
    document.getElementById('section2DDirection').style.display = (settings.mode < 4 || settings.dir3DSource === 1) ? 'block' : 'none';
  }
  
  document.getElementById('mode').addEventListener('change', (e) => {
    settings.mode = parseInt(e.target.value);
    document.getElementById('section3D').style.display = settings.mode >= 4 ? 'block' : 'none';
    update2DDirectionVisibility();
    updateHintVisibility();
    const countSlider = document.getElementById('count'), countVal = document.getElementById('countVal');
    if (settings.mode === 2) { countSlider.max = 5000; settings.count = 2000; }
    else if (settings.mode === 5) { countSlider.max = 2000; settings.count = 200; }
    else { countSlider.max = 2000; settings.count = 1000; }
    countSlider.value = settings.count; countVal.textContent = settings.count;
    resetParticles();
  });
  
  document.getElementById('spawn3DMode').addEventListener('change', (e) => { settings.spawn3DMode = parseInt(e.target.value); });
  document.getElementById('dir3DSource').addEventListener('change', (e) => { settings.dir3DSource = parseInt(e.target.value); update2DDirectionVisibility(); });
  document.getElementById('depthScale').addEventListener('input', (e) => { settings.depthScale = parseInt(e.target.value); updateDisplay('depthScale'); });
  document.getElementById('imgAttr').addEventListener('input', (e) => { settings.imgAttr = parseInt(e.target.value); updateDisplay('imgAttr'); });
  document.getElementById('camDist').addEventListener('input', (e) => { settings.camDist = parseInt(e.target.value); updateDisplay('camDist'); });
  document.getElementById('fov').addEventListener('input', (e) => { settings.fov = parseInt(e.target.value); updateDisplay('fov', '°'); });
  document.getElementById('seed').addEventListener('input', (e) => { settings.seed = parseInt(e.target.value); updateDisplay('seed'); });
  document.getElementById('spawnType').addEventListener('change', (e) => { settings.spawnType = parseInt(e.target.value); if (settings.spawnType === 2) buildBrightnessSampler(); });
  document.getElementById('count').addEventListener('input', (e) => { settings.count = parseInt(e.target.value); updateDisplay('count'); });
  document.getElementById('cutoff').addEventListener('input', (e) => { settings.cutoff = parseInt(e.target.value); updateDisplay('cutoff', '%'); if (settings.spawnType === 2) buildBrightnessSampler(); });
  document.getElementById('lifetime').addEventListener('input', (e) => { settings.lifetime = parseInt(e.target.value); updateDisplay('lifetime'); });
  document.getElementById('size').addEventListener('input', (e) => { settings.size = parseFloat(e.target.value); updateDisplay('size'); });
  document.getElementById('speed').addEventListener('input', (e) => { settings.speed = parseFloat(e.target.value); updateDisplay('speed'); });
  document.getElementById('channel').addEventListener('change', (e) => { settings.channel = parseInt(e.target.value); });
  document.getElementById('shift').addEventListener('input', (e) => { settings.shift = parseInt(e.target.value); updateDisplay('shift', '°'); });
  document.getElementById('fluct').addEventListener('input', (e) => { settings.fluct = parseInt(e.target.value); updateDisplay('fluct', '°'); });
  document.getElementById('dynFluct').addEventListener('input', (e) => { settings.dynFluct = parseInt(e.target.value); updateDisplay('dynFluct', '°'); });
  document.getElementById('attrForce').addEventListener('input', (e) => { settings.attrForce = parseFloat(e.target.value); updateDisplay('attrForce'); });
  document.getElementById('attrAngle').addEventListener('input', (e) => { settings.attrAngle = parseInt(e.target.value); updateDisplay('attrAngle', '°'); });
  document.getElementById('colorMode').addEventListener('change', (e) => { settings.colorMode = parseInt(e.target.value); });
  document.getElementById('customColor').addEventListener('input', (e) => { settings.customColor = e.target.value; });
  document.getElementById('startColor').addEventListener('input', (e) => { settings.startColor = e.target.value; });
  document.getElementById('endColor').addEventListener('input', (e) => { settings.endColor = e.target.value; });
  document.getElementById('transparentBg').addEventListener('change', (e) => { settings.transparentBg = e.target.checked; });
  document.getElementById('bgColor').addEventListener('input', (e) => { settings.bgColor = e.target.value; });
  document.getElementById('fade').addEventListener('input', (e) => { settings.fade = parseInt(e.target.value); updateDisplay('fade'); });
  document.getElementById('resetBtn').addEventListener('click', resetParticles);
  document.getElementById('saveBtn').addEventListener('click', () => { const link = document.createElement('a'); link.download = 'vectory.png'; link.href = canvas.toDataURL(); link.click(); });
  document.getElementById('imageInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      stopWebcam();
      const img = new Image();
      img.onload = () => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = img.width; tempCanvas.height = img.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        sourceData = new Uint8Array(ctx.getImageData(0, 0, img.width, img.height).data);
        sourceWidth = img.width; sourceHeight = img.height;
        updateCanvasSize(); updatePreview(); resetParticles();
      };
      img.src = URL.createObjectURL(file);
    }
  });
  
  document.getElementById('section3D').style.display = settings.mode >= 4 ? 'block' : 'none';
  update2DDirectionVisibility();
  updateHintVisibility();
}

function resetParticles() {
  particleCount = 0; particleIdCounter = 0;
  for (let i = 0; i < MAX_PARTICLES; i++) trailCounts[i] = 0;
  if (settings.spawnType === 2) buildBrightnessSampler();
}

function updateCanvasSize() {
  const container = document.getElementById('canvas-container');
  const maxWidth = container.clientWidth - 32, maxHeight = container.clientHeight - 80;
  const aspectRatio = sourceWidth && sourceHeight ? sourceWidth / sourceHeight : 16/9;
  if (maxWidth / maxHeight > aspectRatio) { canvasHeight = maxHeight; canvasWidth = Math.round(canvasHeight * aspectRatio); }
  else { canvasWidth = maxWidth; canvasHeight = Math.round(canvasWidth / aspectRatio); }
  if (canvas) { canvas.width = canvasWidth; canvas.height = canvasHeight; if (gl) gl.viewport(0, 0, canvasWidth, canvasHeight); }
}

function init() {
  const container = document.getElementById('canvas-container');
  canvasWidth = Math.min(container.clientWidth - 32, container.clientHeight - 80);
  canvasHeight = Math.round(canvasWidth * 9 / 16);
  if (!initWebGL()) return;
  create3DFlowMap();
  updateCanvasSize();
  buildBrightnessSampler();
  setupControls();
  setupMouseControls();
  mainLoop();
}

window.addEventListener('load', init);
window.addEventListener('resize', updateCanvasSize);
</script>
</body>
</html>
